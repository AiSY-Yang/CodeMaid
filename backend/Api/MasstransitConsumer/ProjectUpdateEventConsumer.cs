using MaidContexts;

using MassTransit;

using MasstransitModels;

using Microsoft.EntityFrameworkCore;

using Models.CodeMaid;

namespace Api.MasstransitConsumer
{
	///<inheritdoc/>
	public class ProjectUpdateEventConsumer : IConsumer<ProjectUpdateEvent>
	{
		private readonly ILogger<ProjectUpdateEventConsumer> logger;
		private readonly MaidContext maidContext;

		///<inheritdoc/>
		public ProjectUpdateEventConsumer(ILogger<ProjectUpdateEventConsumer> logger, MaidContext maidContext)
		{
			this.logger = logger;
			this.maidContext = maidContext;
		}
		///<inheritdoc/>
		public async Task Consume(ConsumeContext<ProjectUpdateEvent> context)
		{
			var project = await maidContext.Projects
				.AsSplitQuery()
				.Include(x => x.ProjectDirectories)
				.ThenInclude(x => x.ProjectDirectoryFiles)
				.FirstAsync(x => x.Id == context.Message.ProjectId);
			project.ProjectDirectories.ForEach(x =>
			{
				x.ProjectDirectoryFiles.ForEach(x => x.IsDeleted = true);
				x.IsDeleted = true;
			});
			GetInfo(project.Path);
			void GetInfo(string path)
			{
				var name = Path.GetFileName(path);
				if (new string[] { ".git", "bin", "obj", "node_modules" }.Contains(name)) return;
				var relativePath = Path.GetRelativePath(project.Path, path);
				var projectDirectory = project.ProjectDirectories.FirstOrDefault(x => x.Path == relativePath && x.Name == name);
				if (projectDirectory is null)
				{
					projectDirectory = new ProjectDirectory()
					{
						Project = project,
						ProjectDirectoryFiles = new List<ProjectDirectoryFile>(),
						Name = name,
						Path = Path.GetRelativePath(project.Path, path)
					};
					maidContext.Add(projectDirectory);
				}
				else project.IsDeleted = false;

				var directoryInfo = new DirectoryInfo(path);
				foreach (var item in directoryInfo.EnumerateDirectories())
				{
					GetInfo(item.FullName);
				}
				foreach (var file in directoryInfo.EnumerateFiles("*.cs"))
				{
					var fileType = file.Extension switch
					{
						".cs" => FileType.CSahrp,
						_ => FileType.Other,
					};
					var f = File.ReadAllLines(file.FullName);
					var linesCount = f.Length;
					DateTimeOffset lastWriteTime = file.LastWriteTimeUtc;
					var commentCount = 0;
					var spaceCount = 0;
					var isAutoGen = false;
					if (projectDirectory.Name == "Migrations" || f.FirstOrDefault() == "// <auto-generated />")
					{
						isAutoGen = true;
					}
					switch (fileType)
					{
						case FileType.Other:
							break;
						case FileType.CSahrp:
							foreach (var line in f)
							{
								var trim = line.Trim();
								if (trim == "" || trim == "{" || trim == "}")
									spaceCount++;
								else if (trim.StartsWith("//"))
									commentCount++;
							}
							break;
						default:
							break;
					}
					var projectDirectoryFile = projectDirectory.ProjectDirectoryFiles.Where(x => x.Name == file.Name).FirstOrDefault();
					projectDirectoryFile ??= project.ProjectDirectories.SelectMany(x => x.ProjectDirectoryFiles)
								.FirstOrDefault(x => x.Name == file.Name && x.LastWriteTime == lastWriteTime);
					if (projectDirectoryFile == null)
					{
						projectDirectoryFile = new ProjectDirectoryFile()
						{
							LinesCount = linesCount,
							CommentCount = commentCount,
							SpaceCount = spaceCount,
							ProjectDirectory = projectDirectory,
							FileType = fileType,
							IsAutoGen = isAutoGen,
							Name = file.Name,
							Path = file.FullName,
							LastWriteTime = lastWriteTime,
							IsDeleted = false,
						};
						maidContext.Add(projectDirectoryFile);
					}
					else
					{
						projectDirectoryFile.LinesCount = linesCount;
						projectDirectoryFile.CommentCount = commentCount;
						projectDirectoryFile.SpaceCount = spaceCount;
						projectDirectoryFile.ProjectDirectory = projectDirectory;
						projectDirectoryFile.FileType = fileType;
						projectDirectoryFile.IsAutoGen = isAutoGen;
						projectDirectoryFile.Name = file.Name;
						projectDirectoryFile.Path = file.FullName;
						projectDirectoryFile.LastWriteTime = lastWriteTime;
						projectDirectoryFile.IsDeleted = false;
						maidContext.Update(projectDirectoryFile);
					};
				}
				var adds = maidContext.ChangeTracker.Entries<ProjectDirectoryFile>().Where(x => x.State == EntityState.Added);
				var deletes = maidContext.ChangeTracker.Entries<ProjectDirectoryFile>().Where(x => x.State == EntityState.Modified && x.Entity.IsDeleted == true);
				var modifieds = maidContext.ChangeTracker.Entries<ProjectDirectoryFile>().Where(x => x.State == EntityState.Modified && x.Entity.IsDeleted == false);
				maidContext.SaveChanges();
				//context.PublishBatch<FileChangeEvent>(adds.Select(x => new FileChangeEvent() { FilePath = x.Entity.Path, IsDelete = false, MaidId = 0 }));
			}
		}
	}
	///<inheritdoc/>
	public class ProjectUpdateEventConsumerDefinition : ConsumerDefinition<ProjectUpdateEventConsumer>
	{
		///<inheritdoc/>
		protected override void ConfigureConsumer(IReceiveEndpointConfigurator endpointConfigurator, IConsumerConfigurator<ProjectUpdateEventConsumer> consumerConfigurator, IRegistrationContext context)
		{
		}
	}
}