using Api.Services;

using ExtensionMethods;

using MaidContexts;

using MassTransit;

using MasstransitModels;

using Microsoft.EntityFrameworkCore;

using Models.CodeMaid;

namespace Api.MasstransitConsumer
{
	///<inheritdoc/>
	public class ProjectUpdateEventConsumer : IConsumer<ProjectUpdateEvent>
	{
		private readonly ILogger<ProjectUpdateEventConsumer> logger;
		private readonly MaidContext maidContext;

		///<inheritdoc/>
		public ProjectUpdateEventConsumer(ILogger<ProjectUpdateEventConsumer> logger, MaidContext maidContext)
		{
			this.logger = logger;
			this.maidContext = maidContext;
		}
		///<inheritdoc/>
		public async Task Consume(ConsumeContext<ProjectUpdateEvent> context)
		{
			MaidService.Projects.TryRemove(context.Message.ProjectId, out var p);
			MaidService.Watchers.TryRemove(context.Message.ProjectId, out var watcher);
			if (watcher is not null)
			{
				MaidService.WatcherToProject.TryRemove(watcher, out var _);
				watcher.Dispose();
			}

			var project = await maidContext.Projects
				.AsSplitQuery()
				.Include(x => x.ProjectDirectories)
				.ThenInclude(x => x.ProjectDirectoryFiles)
				.FirstAsync(x => x.Id == context.Message.ProjectId);
			if (!Directory.Exists(project.Path))
			{
				logger.LogError("项目{project}的路径{path}不存在", project.Name, project.Path);
				return;
			}
			project.ProjectDirectories.ForEach(x =>
			{
				x.ProjectDirectoryFiles.ForEach(x => x.IsDeleted = true);
				x.IsDeleted = true;
			});
			GetInfo(project.Path);

			void GetInfo(string path)
			{
				var name = Path.GetFileName(path);
				if (new string[] { ".git", "bin", "obj", "node_modules" }.Contains(name)) return;
				var relativePath = Path.GetRelativePath(project.Path, path);
				var projectDirectory = project.ProjectDirectories.FirstOrDefault(x => x.Path == relativePath && x.Name == name);
				if (projectDirectory is null)
				{
					projectDirectory = new ProjectDirectory()
					{
						Project = project,
						ProjectDirectoryFiles = new List<ProjectDirectoryFile>(),
						Name = name,
						Path = Path.GetRelativePath(project.Path, path)
					};
					maidContext.Add(projectDirectory);
				}
				//else directories.Add(projectDirectory);

				var directoryInfo = new DirectoryInfo(path);
				foreach (var item in directoryInfo.EnumerateDirectories())
				{
					GetInfo(item.FullName);
				}
				foreach (var file in directoryInfo.EnumerateFiles("*.cs"))
				{
					var fileType = file.Extension switch
					{
						".cs" => FileType.CSahrp,
						_ => FileType.Other,
					};
					var f = File.ReadAllLines(file.FullName);
					var linesCount = f.Length;
					DateTimeOffset lastWriteTime = file.LastWriteTime;
					lastWriteTime = lastWriteTime.TruncateNanosecond();
					var commentCount = 0;
					var spaceCount = 0;
					var isAutoGen = false;
					if (projectDirectory.Name == "Migrations" || f.FirstOrDefault() == "// <auto-generated />")
					{
						isAutoGen = true;
					}
					switch (fileType)
					{
						case FileType.Other:
							break;
						case FileType.CSahrp:
							foreach (var line in f)
							{
								var trim = line.Trim();
								if (trim == "" || trim == "{" || trim == "}")
									spaceCount++;
								else if (trim.StartsWith("//"))
									commentCount++;
							}
							break;
						default:
							break;
					}
					var projectDirectoryFile = projectDirectory.ProjectDirectoryFiles.Where(x => x.Name == file.Name).FirstOrDefault();
					projectDirectoryFile ??= project.ProjectDirectories.SelectMany(x => x.ProjectDirectoryFiles)
								.FirstOrDefault(x => x.Name == file.Name && x.LastWriteTime == lastWriteTime && x.LinesCount == linesCount);
					if (projectDirectoryFile == null)
					{
						projectDirectoryFile = new ProjectDirectoryFile()
						{
							Project=project,
							LinesCount = linesCount,
							CommentCount = commentCount,
							SpaceCount = spaceCount,
							ProjectDirectory = projectDirectory,
							FileType = fileType,
							IsAutoGen = isAutoGen,
							Name = file.Name,
							Path = file.FullName,
							LastWriteTime = lastWriteTime,
							IsDeleted = false,
							ProjectStructures = [],
							EnumDefinitions = [],
						};
						maidContext.Add(projectDirectoryFile);
					}
					else
					{
						projectDirectoryFile.LinesCount = linesCount;
						projectDirectoryFile.CommentCount = commentCount;
						projectDirectoryFile.SpaceCount = spaceCount;
						projectDirectoryFile.ProjectDirectory = projectDirectory;
						projectDirectoryFile.FileType = fileType;
						projectDirectoryFile.IsAutoGen = isAutoGen;
						projectDirectoryFile.Name = file.Name;
						projectDirectoryFile.Path = file.FullName;
						projectDirectoryFile.LastWriteTime = lastWriteTime;
						projectDirectoryFile.IsDeleted = false;
					};
				}
			}
			var adds = maidContext.ChangeTracker.Entries<ProjectDirectoryFile>().Where(x => x.State == EntityState.Added).ToList();
			var deletes = maidContext.ChangeTracker.Entries<ProjectDirectoryFile>().Where(x => x.State == EntityState.Modified && x.Entity.IsDeleted == true).ToList();
			var modifieds = maidContext.ChangeTracker.Entries<ProjectDirectoryFile>().Where(x => x.State == EntityState.Modified && x.Entity.IsDeleted == false).ToList();
			maidContext.SaveChanges();
			MaidService.Projects[project.Id] = project;
			watcher = new(project.Path)
			{
				NotifyFilter = NotifyFilters.Attributes
				   | NotifyFilters.CreationTime
				   | NotifyFilters.DirectoryName
				   | NotifyFilters.FileName
				   //   | NotifyFilters.LastAccess
				   | NotifyFilters.LastWrite
				   //   | NotifyFilters.Security
				   | NotifyFilters.Size,
				Filter = "*.cs",
				IncludeSubdirectories = true,
				EnableRaisingEvents = true,
			};
			watcher.Changed += Watcher_Changed;
			watcher.Renamed += Watcher_Changed;
			watcher.Created += Watcher_Changed;
			watcher.Deleted += Watcher_Deleted;

			MaidService.Watchers[project.Id] = watcher;
			MaidService.WatcherToProject[watcher] = project;
			await context.PublishBatch<FileChangeEvent>(adds.Select(x => new FileChangeEvent() { ProjectId = project.Id, ProjectPath = project.Path, FilePath = x.Entity.Path, IsDelete = false }));
			await context.PublishBatch<FileChangeEvent>(deletes.Select(x => new FileChangeEvent() { ProjectId = project.Id, ProjectPath = project.Path, FilePath = x.Entity.Path, IsDelete = true }));
			await context.PublishBatch<FileChangeEvent>(modifieds.Select(x => new FileChangeEvent() { ProjectId = project.Id, ProjectPath = project.Path, FilePath = x.Entity.Path, IsDelete = false }));
		}
		private static async void Watcher_Deleted(object sender, FileSystemEventArgs e)
		{
			await FileChange(MaidService.WatcherToProject[(FileSystemWatcher)sender], e.FullPath, true);
		}
		private static async void Watcher_Changed(object sender, FileSystemEventArgs e)
		{
			await FileChange(MaidService.WatcherToProject[(FileSystemWatcher)sender], e.FullPath, false);
		}
		/// <summary>
		/// 变更筛选器
		/// </summary>
		/// <param name="project"></param>
		/// <param name="filePath">文件路径</param>
		/// <param name="isDelete">是否是删除文件</param>
		/// <returns></returns>
		private static async Task FileChange(Project project, string filePath, bool isDelete)
		{
			var msg = new FileChangeEvent() { ProjectId = project.Id, ProjectPath = project.Path, FilePath = filePath, IsDelete = isDelete };
			using var scope = Program.Services.CreateScope();
			await scope.ServiceProvider.GetRequiredService<IPublishEndpoint>().Publish(msg);
		}
	}
	///<inheritdoc/>
	public class ProjectUpdateEventConsumerDefinition : ConsumerDefinition<ProjectUpdateEventConsumer>
	{
		///<inheritdoc/>
		protected override void ConfigureConsumer(IReceiveEndpointConfigurator endpointConfigurator, IConsumerConfigurator<ProjectUpdateEventConsumer> consumerConfigurator, IRegistrationContext context)
		{
			endpointConfigurator
				.UseScheduledRedelivery(x => x.Interval(9999, TimeSpan.FromSeconds(1)));
		}
	}
}